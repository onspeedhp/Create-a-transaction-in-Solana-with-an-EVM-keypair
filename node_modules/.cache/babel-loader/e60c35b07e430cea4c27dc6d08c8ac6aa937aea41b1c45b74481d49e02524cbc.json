{"ast":null,"code":"import * as web3 from '@solana/web3.js';\nfunction hexToUint8Array(hexString, length) {\n  if (hexString.length !== length * 2) {\n    throw new Error(`Invalid hex string length. Expected ${length * 2} characters.`);\n  }\n  const byteArray = new Uint8Array(length);\n  for (let i = 0, j = 0; i < hexString.length; i += 2, j++) {\n    byteArray[j] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  return byteArray;\n}\nexport const createSignature = async (msg, addr, sig) => {\n  const message = `\\x19Ethereum Signed Message:\\n${msg.length}${msg}`;\n  const messageBuffer = Buffer.from(message, \"utf8\");\n  const ethAddress = hexToUint8Array(addr.slice(2), 20);\n  const signature = hexToUint8Array(sig.slice(2, -2), 64);\n  const recoveryId = parseInt(sig.slice(-2), 16);\n  const example1 = {\n    ethAddress: ethAddress,\n    message: messageBuffer,\n    signature: signature,\n    recoveryId: recoveryId - 27,\n    instructionIndex: 0\n  };\n  const sender = web3.Keypair.generate();\n  const payer = new web3.PublicKey(\"5aMGztMuSVPAp4nm6vrkU25BAho6gGxpWHnnaKZfiUHP\");\n  const instruction = web3.Secp256k1Program.createInstructionWithEthAddress(example1);\n  const transaction = new web3.Transaction();\n  transaction.add(instruction);\n  transaction.add(new web3.TransactionInstruction({\n    data: messageBuffer,\n    keys: [{\n      pubkey: sender.publicKey,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true\n    }],\n    programId: new web3.PublicKey(\"BhEq6GCv279xqKAgRKD2GiKA3Fw4sV3ozx9XKK9GAihX\")\n  }));\n\n  // const payer = new web3.PublicKey(\"5aMGztMuSVPAp4nm6vrkU25BAho6gGxpWHnnaKZfiUHP\");\n\n  const connection = new web3.Connection(\"https://api.devnet.solana.com\");\n\n  // transaction.setSigners(payer);\n\n  // transaction.partialSign(sender);\n\n  const recentBlockhash = (await connection.getLatestBlockhash(\"finalized\")).blockhash;\n  console.log(\"recentBlockhash\", recentBlockhash);\n  // transaction.recentBlockhash = recentBlockhash;\n\n  // convert transaction to base 64\n  // const base64Transaction = transaction.serialize({verifySignatures: false}).toString(\"base64\");\n  const base64Transaction = \"\";\n  const serverUrl = 'http://localhost:8080/transaction';\n  console.log('Sending transaction to server:', base64Transaction);\n  try {\n    const response = await fetch(serverUrl, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        transaction: base64Transaction\n      })\n    });\n    if (response.ok) {\n      const result = await response.json();\n      console.log('Server response:', result);\n    } else {\n      console.error('Error:', response.statusText);\n    }\n  } catch (error) {\n    console.error('Error:', error);\n  }\n\n  // want to sleep for 5 seconds\n  await new Promise(r => setTimeout(r, 5000));\n  // // solana air drop for sender\n  // const airdropSignature = await connection.requestAirdrop(\n  //     sender.publicKey,\n  //     web3.LAMPORTS_PER_SOL\n  // );\n\n  // await connection.confirmTransaction(airdropSignature);\n\n  // const txHash = await web3.sendAndConfirmTransaction(\n  //     connection,\n  //     transaction,\n  //     [payer],\n  //     {\n  //         commitment: \"confirmed\",\n  //         preflightCommitment: \"confirmed\",\n  //     }\n  // );\n\n  // const txHash = \"\";\n\n  const txHash = \"\";\n  return txHash;\n};","map":{"version":3,"names":["web3","hexToUint8Array","hexString","length","Error","byteArray","Uint8Array","i","j","parseInt","slice","createSignature","msg","addr","sig","message","messageBuffer","Buffer","from","ethAddress","signature","recoveryId","example1","instructionIndex","sender","Keypair","generate","payer","PublicKey","instruction","Secp256k1Program","createInstructionWithEthAddress","transaction","Transaction","add","TransactionInstruction","data","keys","pubkey","publicKey","isSigner","isWritable","programId","connection","Connection","recentBlockhash","getLatestBlockhash","blockhash","console","log","base64Transaction","serverUrl","response","fetch","method","headers","body","JSON","stringify","ok","result","json","error","statusText","Promise","r","setTimeout","txHash"],"sources":["/home/katherinee/Desktop/solana/module 1/react-metamask-ethers/src/sendMessage.ts"],"sourcesContent":["import * as web3 from '@solana/web3.js';\n\nexport type CreateSecp256k1InstructionWithEthAddressParams = {\n    ethAddress: Buffer | Uint8Array | Array<number> | string;\n    message: Buffer | Uint8Array | Array<number>;\n    signature: Buffer | Uint8Array | Array<number>;\n    recoveryId: number;\n    instructionIndex?: number;\n  };\n\nfunction hexToUint8Array(hexString: string, length: number): Uint8Array {\nif (hexString.length !== length * 2) {\n    throw new Error(\n    `Invalid hex string length. Expected ${length * 2} characters.`\n    );\n}\nconst byteArray = new Uint8Array(length);\nfor (let i = 0, j = 0; i < hexString.length; i += 2, j++) {\n    byteArray[j] = parseInt(hexString.slice(i, i + 2), 16);\n}\nreturn byteArray;\n}\n\nexport const createSignature = async (msg: string, addr: string, sig: string) => {\n\n    const message = `\\x19Ethereum Signed Message:\\n${msg.length}${msg}`;\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    \n    const ethAddress = hexToUint8Array(addr.slice(2), 20);\n    const signature = hexToUint8Array(sig.slice(2, -2), 64);\n    const recoveryId = parseInt(sig.slice(-2), 16);\n    \n    const example1: CreateSecp256k1InstructionWithEthAddressParams = {\n      ethAddress: ethAddress,\n      message: messageBuffer,\n      signature: signature,\n      recoveryId: recoveryId-27,\n      instructionIndex: 0,\n    };\n\n    const sender = web3.Keypair.generate();\n\n    const payer =  new web3.PublicKey(\"5aMGztMuSVPAp4nm6vrkU25BAho6gGxpWHnnaKZfiUHP\");\n\n    const instruction =\n      web3.Secp256k1Program.createInstructionWithEthAddress(example1);\n\n    const transaction = new web3.Transaction();\n    \n    transaction.add(instruction);\n    \n    transaction.add(\n      new web3.TransactionInstruction({\n        data: messageBuffer,\n        keys: [\n          { \n            pubkey: sender.publicKey, \n            isSigner: true, \n            isWritable: false\n          },\n          {\n            pubkey: payer,\n            isSigner: true,\n            isWritable: true,\n          }\n        ],\n        programId: new web3.PublicKey(\"BhEq6GCv279xqKAgRKD2GiKA3Fw4sV3ozx9XKK9GAihX\"),\n      })\n    );\n\n    // const payer = new web3.PublicKey(\"5aMGztMuSVPAp4nm6vrkU25BAho6gGxpWHnnaKZfiUHP\");\n    \n    const connection = new web3.Connection(\"https://api.devnet.solana.com\");\n   \n    \n    // transaction.setSigners(payer);\n\n    // transaction.partialSign(sender);\n\n    const recentBlockhash = (await connection.getLatestBlockhash(\"finalized\")).blockhash;\n\n    console.log(\"recentBlockhash\", recentBlockhash);\n    // transaction.recentBlockhash = recentBlockhash;\n    \n    // convert transaction to base 64\n    // const base64Transaction = transaction.serialize({verifySignatures: false}).toString(\"base64\");\n      const base64Transaction = \"\";\n    const serverUrl = 'http://localhost:8080/transaction';\n      \n    console.log('Sending transaction to server:', base64Transaction);\n\n    try {\n      const response = await fetch(serverUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({transaction: base64Transaction}),\n      });\n  \n      if (response.ok) {\n        const result = await response.json();\n        console.log('Server response:', result);\n      } else {\n        console.error('Error:', response.statusText);\n      }\n    } catch (error) {\n      console.error('Error:', error);\n    }\n\n    // want to sleep for 5 seconds\n    await new Promise(r => setTimeout(r, 5000));\n    // // solana air drop for sender\n    // const airdropSignature = await connection.requestAirdrop(\n    //     sender.publicKey,\n    //     web3.LAMPORTS_PER_SOL\n    // );\n\n    // await connection.confirmTransaction(airdropSignature);\n\n    // const txHash = await web3.sendAndConfirmTransaction(\n    //     connection,\n    //     transaction,\n    //     [payer],\n    //     {\n    //         commitment: \"confirmed\",\n    //         preflightCommitment: \"confirmed\",\n    //     }\n    // );\n\n    // const txHash = \"\";\n    \n    const txHash = \"\";\n\n    return txHash;\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}