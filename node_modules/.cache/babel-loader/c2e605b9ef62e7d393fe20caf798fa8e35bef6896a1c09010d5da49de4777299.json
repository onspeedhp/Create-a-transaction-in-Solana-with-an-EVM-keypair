{"ast":null,"code":"const cors = require('cors');\nimport * as web3 from '@solana/web3.js';\nfunction hexToUint8Array(hexString, length) {\n  if (hexString.length !== length * 2) {\n    throw new Error(`Invalid hex string length. Expected ${length * 2} characters.`);\n  }\n  const byteArray = new Uint8Array(length);\n  for (let i = 0, j = 0; i < hexString.length; i += 2, j++) {\n    byteArray[j] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  return byteArray;\n}\nexport const createTransaction = async (msg, addr, sig) => {\n  const message = `\\x19Ethereum Signed Message:\\n${msg.length}${msg}`;\n  const messageBuffer = Buffer.from(message, \"utf8\");\n  const ethAddress = hexToUint8Array(addr.slice(2), 20);\n  const signature = hexToUint8Array(sig.slice(2, -2), 64);\n  const recoveryId = parseInt(sig.slice(-2), 16);\n  const example1 = {\n    ethAddress: ethAddress,\n    message: messageBuffer,\n    signature: signature,\n    recoveryId: recoveryId - 27,\n    instructionIndex: 0\n  };\n  const sender = web3.Keypair.generate();\n  const payer = new web3.PublicKey(\"5aMGztMuSVPAp4nm6vrkU25BAho6gGxpWHnnaKZfiUHP\");\n  const instruction = web3.Secp256k1Program.createInstructionWithEthAddress(example1);\n  const connection = new web3.Connection(\"http://localhost:8899\");\n  const transaction = new web3.TransactionMessage({\n    payerKey: payer,\n    recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n    instructions: [instruction]\n  });\n\n  // transaction.add(instruction);\n\n  // transaction.add(\n  //   new web3.TransactionInstruction({\n  //     data: messageBuffer,\n  //     keys: [\n  //       { \n  //         pubkey: sender.publicKey, \n  //         isSigner: true, \n  //         isWritable: false\n  //       },\n  //       {\n  //         pubkey: payer,\n  //         isSigner: true,\n  //         isWritable: true,\n  //       }\n  //     ],\n  //     programId: new web3.PublicKey(\"BhEq6GCv279xqKAgRKD2GiKA3Fw4sV3ozx9XKK9GAihX\"),\n  //   })\n  // );\n\n  const serverUrl = 'http://localhost:8080/transaction';\n\n  // encode the transaction to base64\n  // const encodedTransaction = transaction.serialize().toString('base64');\n\n  return encodedTransaction;\n};","map":{"version":3,"names":["cors","require","web3","hexToUint8Array","hexString","length","Error","byteArray","Uint8Array","i","j","parseInt","slice","createTransaction","msg","addr","sig","message","messageBuffer","Buffer","from","ethAddress","signature","recoveryId","example1","instructionIndex","sender","Keypair","generate","payer","PublicKey","instruction","Secp256k1Program","createInstructionWithEthAddress","connection","Connection","transaction","TransactionMessage","payerKey","recentBlockhash","getLatestBlockhash","blockhash","instructions","serverUrl","encodedTransaction"],"sources":["/home/katherinee/Desktop/solana/module 1/react-metamask-ethers/src/sendMessage.ts"],"sourcesContent":["const cors = require('cors');\nimport * as web3 from '@solana/web3.js';\n\nexport type CreateSecp256k1InstructionWithEthAddressParams = {\n    ethAddress: Buffer | Uint8Array | Array<number> | string;\n    message: Buffer | Uint8Array | Array<number>;\n    signature: Buffer | Uint8Array | Array<number>;\n    recoveryId: number;\n    instructionIndex?: number;\n  };\n\nfunction hexToUint8Array(hexString: string, length: number): Uint8Array {\nif (hexString.length !== length * 2) {\n    throw new Error(\n    `Invalid hex string length. Expected ${length * 2} characters.`\n    );\n}\nconst byteArray = new Uint8Array(length);\nfor (let i = 0, j = 0; i < hexString.length; i += 2, j++) {\n    byteArray[j] = parseInt(hexString.slice(i, i + 2), 16);\n}\nreturn byteArray;\n}\n\nexport const createTransaction = async (msg: string, addr: string, sig: string) => {\n\n    const message = `\\x19Ethereum Signed Message:\\n${msg.length}${msg}`;\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    \n    const ethAddress = hexToUint8Array(addr.slice(2), 20);\n    const signature = hexToUint8Array(sig.slice(2, -2), 64);\n    const recoveryId = parseInt(sig.slice(-2), 16);\n    \n    const example1: CreateSecp256k1InstructionWithEthAddressParams = {\n      ethAddress: ethAddress,\n      message: messageBuffer,\n      signature: signature,\n      recoveryId: recoveryId-27,\n      instructionIndex: 0,\n    };\n    \n    const sender = web3.Keypair.generate();\n\n    const payer =  new web3.PublicKey(\"5aMGztMuSVPAp4nm6vrkU25BAho6gGxpWHnnaKZfiUHP\");\n\n    const instruction =\n      web3.Secp256k1Program.createInstructionWithEthAddress(example1);\n\n    const connection = new web3.Connection(\"http://localhost:8899\");\n\n    const transaction = new web3.TransactionMessage({\n      payerKey: payer,\n      recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n      instructions: [instruction],\n    });\n    \n    // transaction.add(instruction);\n    \n    // transaction.add(\n    //   new web3.TransactionInstruction({\n    //     data: messageBuffer,\n    //     keys: [\n    //       { \n    //         pubkey: sender.publicKey, \n    //         isSigner: true, \n    //         isWritable: false\n    //       },\n    //       {\n    //         pubkey: payer,\n    //         isSigner: true,\n    //         isWritable: true,\n    //       }\n    //     ],\n    //     programId: new web3.PublicKey(\"BhEq6GCv279xqKAgRKD2GiKA3Fw4sV3ozx9XKK9GAihX\"),\n    //   })\n    // );\n        \n\n    const serverUrl = 'http://localhost:8080/transaction';\n          \n    // encode the transaction to base64\n    // const encodedTransaction = transaction.serialize().toString('base64');\n\n\n    return encodedTransaction;\n};\n\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC5B,OAAO,KAAKC,IAAI,MAAM,iBAAiB;AAUvC,SAASC,eAAeA,CAACC,SAAiB,EAAEC,MAAc,EAAc;EACxE,IAAID,SAAS,CAACC,MAAM,KAAKA,MAAM,GAAG,CAAC,EAAE;IACjC,MAAM,IAAIC,KAAK,CACd,uCAAsCD,MAAM,GAAG,CAAE,cAAa,CAC9D;EACL;EACA,MAAME,SAAS,GAAG,IAAIC,UAAU,CAACH,MAAM,CAAC;EACxC,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGL,SAAS,CAACC,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAEC,CAAC,EAAE,EAAE;IACtDH,SAAS,CAACG,CAAC,CAAC,GAAGC,QAAQ,CAACP,SAAS,CAACQ,KAAK,CAACH,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;EAC1D;EACA,OAAOF,SAAS;AAChB;AAEA,OAAO,MAAMM,iBAAiB,GAAG,MAAAA,CAAOC,GAAW,EAAEC,IAAY,EAAEC,GAAW,KAAK;EAE/E,MAAMC,OAAO,GAAI,iCAAgCH,GAAG,CAACT,MAAO,GAAES,GAAI,EAAC;EACnE,MAAMI,aAAa,GAAGC,MAAM,CAACC,IAAI,CAACH,OAAO,EAAE,MAAM,CAAC;EAElD,MAAMI,UAAU,GAAGlB,eAAe,CAACY,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EACrD,MAAMU,SAAS,GAAGnB,eAAe,CAACa,GAAG,CAACJ,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EACvD,MAAMW,UAAU,GAAGZ,QAAQ,CAACK,GAAG,CAACJ,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAE9C,MAAMY,QAAwD,GAAG;IAC/DH,UAAU,EAAEA,UAAU;IACtBJ,OAAO,EAAEC,aAAa;IACtBI,SAAS,EAAEA,SAAS;IACpBC,UAAU,EAAEA,UAAU,GAAC,EAAE;IACzBE,gBAAgB,EAAE;EACpB,CAAC;EAED,MAAMC,MAAM,GAAGxB,IAAI,CAACyB,OAAO,CAACC,QAAQ,EAAE;EAEtC,MAAMC,KAAK,GAAI,IAAI3B,IAAI,CAAC4B,SAAS,CAAC,8CAA8C,CAAC;EAEjF,MAAMC,WAAW,GACf7B,IAAI,CAAC8B,gBAAgB,CAACC,+BAA+B,CAACT,QAAQ,CAAC;EAEjE,MAAMU,UAAU,GAAG,IAAIhC,IAAI,CAACiC,UAAU,CAAC,uBAAuB,CAAC;EAE/D,MAAMC,WAAW,GAAG,IAAIlC,IAAI,CAACmC,kBAAkB,CAAC;IAC9CC,QAAQ,EAAET,KAAK;IACfU,eAAe,EAAE,CAAC,MAAML,UAAU,CAACM,kBAAkB,EAAE,EAAEC,SAAS;IAClEC,YAAY,EAAE,CAACX,WAAW;EAC5B,CAAC,CAAC;;EAEF;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAGA,MAAMY,SAAS,GAAG,mCAAmC;;EAErD;EACA;;EAGA,OAAOC,kBAAkB;AAC7B,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}